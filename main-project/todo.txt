HUSKS:
______
- phis
- copy propagation
- common subexpression elemination
- der der løbende linked list halløj (?)
- doms (også i graf)
- Arrays
- end instr? exit block?

QUESTIONS:
______
- Skal jeg dække return stm?

OVERVEJELSER:
______
- error handling. Like hvad hvis der er noget i check token der ikke passer. Skal det så fortsætte?
- skal jeg copy table over med var instr id i stedet for at lave recursion method?


NEXTS:
______
x implement det samme for while ift branches (like if)
x tjek SSA for built-in funcs
x add var værdier til grafen for debugging purposes
- phis (måde at holde styr på hvad der skal samles -> kan også være at kopierer var tabeller med og så se hvad der skal sammenholdes/ikke er det samme længere fra de to sider)
    x du skal nok kopierer tabeller ned
    - phi'en skal tilføjes så snart der er en assignment (så den tæller instr id correct)
- check what happens in phi when variable is declared first time inside then and else (altså ikke ovenover)
- add bra instruction number. Skal tilføjes så snart phi er færdig (altså før andet i den blok - se papir)
- take out stuff related to user funcs fordi du kun er en person  eller bare pass keyword
- dom
x du skal nok opdatere visul. så at den laver [] med de forskellige tre typer og så sætter dem sammen til sidst, så de samme kommer i samme rækkefølge
- fix så hvis det er if then return og noget efter if så har den branch blok ikke en empty men det der kommer efter

______
x Alle while og if ender ud i en assignment, i.e. der skal være en join blok for enden af den tråd.
x Så når du støder på den første assignment så laver du en join blok og opdaterer var "cur_join_block" til den blok
    - du kigger så opad for at finde den nuværende instr for den variabel og så sætter du den nye og den du har fundet længere oppe ind i phi i cur_join_block
x ift branching ud af if eller else ->
    - hvis der er else branch og det næste ikke er if/while så bliver den else blok en af parent til cur_join_block
    - hvis der ikke er else branch så bliver den blok hvor if er i en af parent til cur_join_block
x tjek forskellige kombinationer af if-stmt ift branches
x tilføj branch instruction til end of then blok (du skal finde ud af at få nr på der hvor der skal branches hen)
x den blok der kommer if/then/else skal samle dem alle (så skal nok et level op for at kunne lave den)
x then branch instruction id - branch id skal være før der arbejdes på else i.e. det nr skal være før den første else ting
x else block branch label/block

____

x Gør det samme du har gjort med * and / med + og -
- tilføj andre steder der skal laves SSA
    x write
    x read
    x cpm
    x branches various types
- så join blokke og hvad der hører med ift dom og phi
- når du så har graf med de ting, så kan vi begynde at tænke i optimering og det med traversing igen for while/if

____

x Forstæt med id op fra designator. Så du kan bruge det i factor -> term -> exp. Der skal der så genereres SSA og indsættes i current BB.
x Der skal også opdateres i var tabellen ved assignment

x Lav BB med andre steder
x Lav tabel til at holde var assignments/instr navne. Det er nok noget med deres token nr -> instr nr.
    - Når der laves ny BB så skal den kopiere parent table ned
- Create SSA og indsæt i BB (opdater instr counts)

- Create dom data structure (only dom instr appear)

____

x Fortsæt graf class for BB:
    x Få den til bare at lave blocks med tomme instr.
    x Husk at se om join block ift text på blokken
    x Få den til at lave pile mellem blokke.
    x lav skelet til dom i graf men gem halløjet selv
- begynd at kigge på SSA instr'erne
    - du skal tænke over hvordan du vil holde styr på variable numre. Du har den der genererer i SSA, men kan du bruge deres id numre minus noget
    - der er også det at hvis det bare bliver assigned så er det ikke en instr men join), så måske skal hver block have den der tabel med variabel -> (instr_værdi)
- så bliver det nok join block + phi bagefter

_________

- Lav instruction block class
- Lav BB class -> se billede
- Få de forskellige der skal lave ny BB til at lave dem
- Lav noget main metode der kører noget
- Få instr ind i BBs
- Lav graph class der laver graph baseret på din BB struktur

_________

1. Check om func navnet er et af de allerede definerede √
    Du skal også tjekke videre med i parenteserne for at tjekke at de kalder den gyldigt. √
2. Opdater symbol tabel når der laves vars √
    Skip arrays og user defined funcs for nu √
3. Check for uninitialized variables (se beskrivelse om at = 0 men warning) √

5. Få den til at give instructions tilbage i stedet for det nuværende return

THEN
Så skal du til at tænke over hvilken data struktur du vil bruge til de der statements, sådan at det "træ" bygges løbende
Kræver at du fatter:
- Basic blocks
- phis
- Så er der et eller andet med at gemme noget man har set løbende i linked list eller sådan noget -> kig på dine noter ift ekstra krævede data strukturer
! -> GENERELT nu er et godt tidspunkt lige at fatte det der er sket i timerne helt så du også kan opdatere den her liste med de steps der skal overvejes

1. Byg data strukturen -> nok noget OO struktur med basic block med ting indeni, pointers og så videre
    Der skal laves en root/BB0 hvor der på root kan tilføjes constants, i.e., de numre vi møder
2. Depends on hvad konklusionerne er fra at kigge på noter, etc.

THEN
Lav noget der kan konvertere din data struktur træ til det der graf halløj

THEN
- copy propagation
- common subexpression elemination













    def add_phis_if(self, if_block: BasicBlock, then_block: BasicBlock, else_block: BasicBlock):
        already_added_vars = set()
        join_block: BasicBlock = self.blocks.get_current_join_block()

        # Joining var that has been updated both in then and else
        intersection_then_else = then_block.get_updated_vars().intersection(else_block.get_updated_vars())
        for child in intersection_then_else:
            if child not in already_added_vars:
                then_instr_child = then_block.get_vars()[child]
                else_instr_child = else_block.get_vars()[child]
                join_block.add_new_instr(instr_id=self.baseSSA.get_new_instr_id(), op=Operations.PHI, x=else_instr_child,
                                         y=then_instr_child)
                already_added_vars.add(child)

        intersection_if_then = if_block.get_updated_vars().intersection(then_block.get_updated_vars())
        for child in intersection_if_then:
            if child not in already_added_vars:
                if_instr_child = if_block.get_vars()[child]
                then_instr_child = then_block.get_vars()[child]
                join_block.add_new_instr(instr_id=self.baseSSA.get_new_instr_id(), op=Operations.PHI,
                                         x=then_instr_child,
                                         y=if_instr_child)
                already_added_vars.add(child)

        intersection_if_else = if_block.get_updated_vars().intersection(else_block.get_updated_vars())
        for child in intersection_if_else:
            if child not in already_added_vars:
                if_instr_child = if_block.get_vars()[child]
                else_instr_child = then_block.get_vars()[child]
                join_block.add_new_instr(instr_id=self.baseSSA.get_new_instr_id(), op=Operations.PHI,
                                         x=else_instr_child,
                                         y=if_instr_child)
                already_added_vars.add(child)

        if already_added_vars:
            join_block.update_join(True)
