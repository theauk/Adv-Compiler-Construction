

Stuff now:
______
- Arrays
    x Initial storing
    - Initial loading
    - Make actual loading instruction set (all that multiply, etc.)
    - Make actual storing instruction
    - Keep a list of already done loading instr and pass down dominating blocks
        - Kill one if it gets updated
        - Reuse loading instr if it is still valid


Stuff later:
______
- Numberings after cse
- Take out stuff related to user funcs
- Remove branch block when ret???


Questions:
______
- Phis after ret + branch after ret?
- Number for then branch instr. Is it okay if the number is the next number after last else instr?
- Is it okay if branch instr number is after phi instr numbers? E.g. branch in while being 24 and the phi above it being 23?
    - er lidt relateret til nedenstående
- CHECK complex while test case:
    can an instr have a future instr. See join 17 (since both are phi)
    generally numbering of phis in if (me immediately) vs while (me after)


NOTES:
______

x fix phi numbering og factor
x fix so that if you have nested while the branch falls out to the already existing "out" block and does not make a new one
x put empty i empty while blocks
x check kombi af while og if
x add dom arrows

x phi should be propegated so e.g. if only assign in inner inner while there should also be phi further out
x update instr numbers downstream after adding phis
x during second pass also update the bra y værdi til den første instr i den while blokken brancher til
x remove bra instruction that mistakenly gets inserted for two non nested while sts

x check instructions in relop
x figure out why block disappears
x figure out why phis on while top now disappeared

x common subexpression elimination
    x add sets
    x check sets before adding instr and decrease id if necessary
    x any stuff that will change when instr are updated downstream after while phis

______
x implement det samme for while ift branches (like if)
x tjek SSA for built-in funcs
x add var værdier til grafen for debugging purposes
x phis for if (måde at holde styr på hvad der skal samles -> kan også være at kopierer var tabeller med og så se hvad der skal sammenholdes/ikke er det samme længere fra de to sider)
    x du skal nok kopierer tabeller ned
    x phi'en skal tilføjes så snart der er en assignment (så den tæller instr id correct)
    x add phi instr x and y
x add bra instruction number. Skal tilføjes så snart phi er færdig (altså før andet i den blok - se papir)
x du skal nok opdatere visul. så at den laver [] med de forskellige tre typer og så sætter dem sammen til sidst, så de samme kommer i samme rækkefølge
x check what happens in phi when variable is declared first time inside then and else (altså ikke ovenover)
x update dicts for join block so it is ready for another e.g. if
x phis for while

______
x Alle while og if ender ud i en assignment, i.e. der skal være en join blok for enden af den tråd.
x Så når du støder på den første assignment så laver du en join blok og opdaterer var "cur_join_block" til den blok
    - du kigger så opad for at finde den nuværende instr for den variabel og så sætter du den nye og den du har fundet længere oppe ind i phi i cur_join_block
x ift branching ud af if eller else ->
    - hvis der er else branch og det næste ikke er if/while så bliver den else blok en af parent til cur_join_block
    - hvis der ikke er else branch så bliver den blok hvor if er i en af parent til cur_join_block
x tjek forskellige kombinationer af if-stmt ift branches
x tilføj branch instruction til end of then blok (du skal finde ud af at få nr på der hvor der skal branches hen)
x den blok der kommer if/then/else skal samle dem alle (så skal nok et level op for at kunne lave den)
x then branch instruction id - branch id skal være før der arbejdes på else i.e. det nr skal være før den første else ting
x else block branch label/block

____

x Gør det samme du har gjort med * and / med + og -
- tilføj andre steder der skal laves SSA
    x write
    x read
    x cpm
    x branches various types
- så join blokke og hvad der hører med ift dom og phi
- når du så har graf med de ting, så kan vi begynde at tænke i optimering og det med traversing igen for while/if

____

x Forstæt med id op fra designator. Så du kan bruge det i factor -> term -> exp. Der skal der så genereres SSA og indsættes i current BB.
x Der skal også opdateres i var tabellen ved assignment

x Lav BB med andre steder
x Lav tabel til at holde var assignments/instr navne. Det er nok noget med deres token nr -> instr nr.
    - Når der laves ny BB så skal den kopiere parent table ned
- Create SSA og indsæt i BB (opdater instr counts)

- Create dom data structure (only dom instr appear)

____

x Fortsæt graf class for BB:
    x Få den til bare at lave blocks med tomme instr.
    x Husk at se om join block ift text på blokken
    x Få den til at lave pile mellem blokke.
    x lav skelet til dom i graf men gem halløjet selv
- begynd at kigge på SSA instr'erne
    - du skal tænke over hvordan du vil holde styr på variable numre. Du har den der genererer i SSA, men kan du bruge deres id numre minus noget
    - der er også det at hvis det bare bliver assigned så er det ikke en instr men join), så måske skal hver block have den der tabel med variabel -> (instr_værdi)
- så bliver det nok join block + phi bagefter

_________

- Lav instruction block class
- Lav BB class -> se billede
- Få de forskellige der skal lave ny BB til at lave dem
- Lav noget main metode der kører noget
- Få instr ind i BBs
- Lav graph class der laver graph baseret på din BB struktur

_________

1. Check om func navnet er et af de allerede definerede √
    Du skal også tjekke videre med i parenteserne for at tjekke at de kalder den gyldigt. √
2. Opdater symbol tabel når der laves vars √
    Skip arrays og user defined funcs for nu √
3. Check for uninitialized variables (se beskrivelse om at = 0 men warning) √

5. Få den til at give instructions tilbage i stedet for det nuværende return

THEN
Så skal du til at tænke over hvilken data struktur du vil bruge til de der statements, sådan at det "træ" bygges løbende
Kræver at du fatter:
- Basic blocks
- phis
- Så er der et eller andet med at gemme noget man har set løbende i linked list eller sådan noget -> kig på dine noter ift ekstra krævede data strukturer
! -> GENERELT nu er et godt tidspunkt lige at fatte det der er sket i timerne helt så du også kan opdatere den her liste med de steps der skal overvejes

1. Byg data strukturen -> nok noget OO struktur med basic block med ting indeni, pointers og så videre
    Der skal laves en root/BB0 hvor der på root kan tilføjes constants, i.e., de numre vi møder
2. Depends on hvad konklusionerne er fra at kigge på noter, etc.

THEN
Lav noget der kan konvertere din data struktur træ til det der graf halløj

THEN
- copy propagation
- common subexpression elemination