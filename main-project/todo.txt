while and vars:
do not copy instrs that have vars as x or y from while block to then block
but do copy instr into branch for vars that do not get updated
    would probably have to check updated var list for then before continuing to branch block
    but what about while in while?
        might have to propegate up the updated vars

ehm hvad med add (1) (2) vs add (2) (1)??? altså hvor rækkefølge does not matter

let a <- 1 + 2;
let b <- 2 + a;

while a < 2 do [a has been updated]
    while a < 2 do [a has been updated]
        let a <- 2 + a # not cse
    od;
    let a <- 2 + a # not cse [ALSO TRY WITHOUT THIS]
od;

let b <- 2 + a # not cse since a might have been updated [do not copy 2 + a down because a has been updated]

let a <- 1 + 2;
let b <- 2 + b;

while a < 2 do
    while a < 2 do
        let a <- 2 + a # not cse
    od;
    let a <- 2 + a # not cse
od;

let b <- 2 + b # cse since b has not been updated [copy 2 + b down since b has NOT been updated]


x 1. update Instr to have the vars
x 2. when in do not cse
3. second pass while
    - make a dict (instr, instr_var) -> updated phi instr
    - when you see phi do dict[(x, x_var)] = its phi instr
    - when you see (x, x_var) or (y, y_var) as one of the (instr, instr_var) then update it to corresponding dict instr
        - update dom instr FIGURE OUT HOW TO APPROACH THIS because it should spread, cannot just add var since sometimes even with dif var it should be eliminated + updates should propegate. Might need to rethink how I make and copy those
4. third pass while
    - check for cse
    - update instr numbering if cse



HUSKS:
______
- phis
- copy propagation
- common subexpression elemination
- der der løbende linked list halløj (?)
- doms (også i graf)
- Arrays
- end instr? exit block?

QUESTIONS:
______
- Skal jeg dække return stm?
- hvad skal der ske med branch blok med to while efter hinanden
- skal der være end instruction?

OVERVEJELSER:
______
- error handling. Like hvad hvis der er noget i check token der ikke passer. Skal det så fortsætte?


NEXTS:
______

- make tests
- hvad skal der ske med branch blok med to while efter hinanden
- arrays (?!)

- fix så hvis det er if then "return" og noget efter if så har den branch blok ikke en empty men det der kommer efter
- take out stuff related to user funcs fordi du kun er en person  eller bare pass keyword
______

x fix phi numbering og factor
x fix so that if you have nested while the branch falls out to the already existing "out" block and does not make a new one
x put empty i empty while blocks
x check kombi af while og if
x add dom arrows

x phi should be propegated so e.g. if only assign in inner inner while there should also be phi further out
x update instr numbers downstream after adding phis
x during second pass also update the bra y værdi til den første instr i den while blokken brancher til
x remove bra instruction that mistakenly gets inserted for two non nested while sts

x check instructions in relop
x figure out why block disappears
x figure out why phis on while top now disappeared

x common subexpression elimination
    x add sets
    x check sets before adding instr and decrease id if necessary
    x any stuff that will change when instr are updated downstream after while phis

______
x implement det samme for while ift branches (like if)
x tjek SSA for built-in funcs
x add var værdier til grafen for debugging purposes
x phis for if (måde at holde styr på hvad der skal samles -> kan også være at kopierer var tabeller med og så se hvad der skal sammenholdes/ikke er det samme længere fra de to sider)
    x du skal nok kopierer tabeller ned
    x phi'en skal tilføjes så snart der er en assignment (så den tæller instr id correct)
    x add phi instr x and y
x add bra instruction number. Skal tilføjes så snart phi er færdig (altså før andet i den blok - se papir)
x du skal nok opdatere visul. så at den laver [] med de forskellige tre typer og så sætter dem sammen til sidst, så de samme kommer i samme rækkefølge
x check what happens in phi when variable is declared first time inside then and else (altså ikke ovenover)
x update dicts for join block so it is ready for another e.g. if
x phis for while

______
x Alle while og if ender ud i en assignment, i.e. der skal være en join blok for enden af den tråd.
x Så når du støder på den første assignment så laver du en join blok og opdaterer var "cur_join_block" til den blok
    - du kigger så opad for at finde den nuværende instr for den variabel og så sætter du den nye og den du har fundet længere oppe ind i phi i cur_join_block
x ift branching ud af if eller else ->
    - hvis der er else branch og det næste ikke er if/while så bliver den else blok en af parent til cur_join_block
    - hvis der ikke er else branch så bliver den blok hvor if er i en af parent til cur_join_block
x tjek forskellige kombinationer af if-stmt ift branches
x tilføj branch instruction til end of then blok (du skal finde ud af at få nr på der hvor der skal branches hen)
x den blok der kommer if/then/else skal samle dem alle (så skal nok et level op for at kunne lave den)
x then branch instruction id - branch id skal være før der arbejdes på else i.e. det nr skal være før den første else ting
x else block branch label/block

____

x Gør det samme du har gjort med * and / med + og -
- tilføj andre steder der skal laves SSA
    x write
    x read
    x cpm
    x branches various types
- så join blokke og hvad der hører med ift dom og phi
- når du så har graf med de ting, så kan vi begynde at tænke i optimering og det med traversing igen for while/if

____

x Forstæt med id op fra designator. Så du kan bruge det i factor -> term -> exp. Der skal der så genereres SSA og indsættes i current BB.
x Der skal også opdateres i var tabellen ved assignment

x Lav BB med andre steder
x Lav tabel til at holde var assignments/instr navne. Det er nok noget med deres token nr -> instr nr.
    - Når der laves ny BB så skal den kopiere parent table ned
- Create SSA og indsæt i BB (opdater instr counts)

- Create dom data structure (only dom instr appear)

____

x Fortsæt graf class for BB:
    x Få den til bare at lave blocks med tomme instr.
    x Husk at se om join block ift text på blokken
    x Få den til at lave pile mellem blokke.
    x lav skelet til dom i graf men gem halløjet selv
- begynd at kigge på SSA instr'erne
    - du skal tænke over hvordan du vil holde styr på variable numre. Du har den der genererer i SSA, men kan du bruge deres id numre minus noget
    - der er også det at hvis det bare bliver assigned så er det ikke en instr men join), så måske skal hver block have den der tabel med variabel -> (instr_værdi)
- så bliver det nok join block + phi bagefter

_________

- Lav instruction block class
- Lav BB class -> se billede
- Få de forskellige der skal lave ny BB til at lave dem
- Lav noget main metode der kører noget
- Få instr ind i BBs
- Lav graph class der laver graph baseret på din BB struktur

_________

1. Check om func navnet er et af de allerede definerede √
    Du skal også tjekke videre med i parenteserne for at tjekke at de kalder den gyldigt. √
2. Opdater symbol tabel når der laves vars √
    Skip arrays og user defined funcs for nu √
3. Check for uninitialized variables (se beskrivelse om at = 0 men warning) √

5. Få den til at give instructions tilbage i stedet for det nuværende return

THEN
Så skal du til at tænke over hvilken data struktur du vil bruge til de der statements, sådan at det "træ" bygges løbende
Kræver at du fatter:
- Basic blocks
- phis
- Så er der et eller andet med at gemme noget man har set løbende i linked list eller sådan noget -> kig på dine noter ift ekstra krævede data strukturer
! -> GENERELT nu er et godt tidspunkt lige at fatte det der er sket i timerne helt så du også kan opdatere den her liste med de steps der skal overvejes

1. Byg data strukturen -> nok noget OO struktur med basic block med ting indeni, pointers og så videre
    Der skal laves en root/BB0 hvor der på root kan tilføjes constants, i.e., de numre vi møder
2. Depends on hvad konklusionerne er fra at kigge på noter, etc.

THEN
Lav noget der kan konvertere din data struktur træ til det der graf halløj

THEN
- copy propagation
- common subexpression elemination