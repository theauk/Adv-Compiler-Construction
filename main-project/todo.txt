HUSKS:
______
- phis
- copy propagation
- common subexpression elemination
- der der løbende linked list halløj (?)
- doms (også i graf)

OVERVEJELSER:
______
- Skal der også være next/children inde i en block? Er der brug for det for at traverse senere?
- Arrays
- error handling. Like hvad hvis der er noget i check token der ikke passer. Skal det så fortsætte?


NEXTS:
____
- then branch instruction id (don't know when created)
- else block branch label/block
- then block branch label/block (don't know the next instr yet and there might not be more code)

____

x Gør det samme du har gjort med * and / med + og -
- tilføj andre steder der skal laves SSA
    x write
    x read
    - cpm
    - end???
    - branches various types
- take out stuff related to user funcs fordi du kun er en person
    - eller bare pass keyword
- prøv at kør på basic program og se om det er helt væk/ret fejl for at få nogenlunde graf
- så join blokke og hvad der hører med ift dom og phi
- når du så har graf med de ting, så kan vi begynde at tænke i optimering og det med traversing igen for while/if


____

x Forstæt med id op fra designator. Så du kan bruge det i factor -> term -> exp. Der skal der så genereres SSA og indsættes i current BB.
x Der skal også opdateres i var tabellen ved assignment

x Lav BB med andre steder
x Lav tabel til at holde var assignments/instr navne. Det er nok noget med deres token nr -> instr nr.
    - Når der laves ny BB så skal den kopiere parent table ned
- Create SSA og indsæt i BB (opdater instr counts)

- Create dom data structure (only dom instr appear)

____

x Fortsæt graf class for BB:
    x Få den til bare at lave blocks med tomme instr.
    x Husk at se om join block ift text på blokken
    x Få den til at lave pile mellem blokke.
    x lav skelet til dom i graf men gem halløjet selv
- begynd at kigge på SSA instr'erne
    - du skal tænke over hvordan du vil holde styr på variable numre. Du har den der genererer i SSA, men kan du bruge deres id numre minus noget
    - der er også det at hvis det bare bliver assigned så er det ikke en instr men join), så måske skal hver block have den der tabel med variabel -> (instr_værdi)
- så bliver det nok join block + phi bagefter

_________

- Lav instruction block class
- Lav BB class -> se billede
- Få de forskellige der skal lave ny BB til at lave dem
- Lav noget main metode der kører noget
- Få instr ind i BBs
- Lav graph class der laver graph baseret på din BB struktur

_________

1. Check om func navnet er et af de allerede definerede √
    Du skal også tjekke videre med i parenteserne for at tjekke at de kalder den gyldigt. √
2. Opdater symbol tabel når der laves vars √
    Skip arrays og user defined funcs for nu √
3. Check for uninitialized variables (se beskrivelse om at = 0 men warning) √

5. Få den til at give instructions tilbage i stedet for det nuværende return

THEN
Så skal du til at tænke over hvilken data struktur du vil bruge til de der statements, sådan at det "træ" bygges løbende
Kræver at du fatter:
- Basic blocks
- phis
- Så er der et eller andet med at gemme noget man har set løbende i linked list eller sådan noget -> kig på dine noter ift ekstra krævede data strukturer
! -> GENERELT nu er et godt tidspunkt lige at fatte det der er sket i timerne helt så du også kan opdatere den her liste med de steps der skal overvejes

1. Byg data strukturen -> nok noget OO struktur med basic block med ting indeni, pointers og så videre
    Der skal laves en root/BB0 hvor der på root kan tilføjes constants, i.e., de numre vi møder
2. Depends on hvad konklusionerne er fra at kigge på noter, etc.

THEN
Lav noget der kan konvertere din data struktur træ til det der graf halløj

THEN
- copy propagation
- common subexpression elemination
